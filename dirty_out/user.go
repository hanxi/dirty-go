// Code generated by dirty-go; DO NOT EDIT.
package dirty_out

import (
	"encoding/json"
	"github.com/hanxi/dirty-go/dirty_tmpl"
)

type BaseInfo struct {
	Base
	lv  uint32
	exp uint32
}

func NewBaseInfo() *BaseInfo {
	p := &BaseInfo{}
	p.self = p
	p.root = p
	return p
}

func (p *BaseInfo) SetLv(value uint32) {
	if p == nil {
		return
	}
	p.lv = value
	p.NotifyDirty()
}

func (p *BaseInfo) GetLv() uint32 {
	if p == nil {
		return 0
	}
	return p.lv
}

func (p *BaseInfo) SetExp(value uint32) {
	if p == nil {
		return
	}
	p.exp = value
	p.NotifyDirty()
}

func (p *BaseInfo) GetExp() uint32 {
	if p == nil {
		return 0
	}
	return p.exp
}

func (p *BaseInfo) fromOrigin(o *dirty_tmpl.BaseInfo) {
	p.lv = o.Lv
	p.exp = o.Exp
}

func (p *BaseInfo) toOrigin() *dirty_tmpl.BaseInfo {
	if p == nil {
		return nil
	}
	o := &dirty_tmpl.BaseInfo{}
	o.Lv = p.lv
	o.Exp = p.exp
	return o
}

func (p *BaseInfo) UnmarshalJSON(data []byte) error {
	origin := &dirty_tmpl.BaseInfo{}
	if err := json.Unmarshal(data, origin); err != nil {
		return err
	}
	p.fromOrigin(origin)
	return nil
}

func (p *BaseInfo) MarshalJSON() ([]byte, error) {
	origin := p.toOrigin()
	return json.Marshal(origin)
}

type Resource struct {
	Base
	id    uint32
	value uint32
	size  uint32
}

func NewResource() *Resource {
	p := &Resource{}
	p.self = p
	p.root = p
	return p
}

func (p *Resource) SetId(value uint32) {
	if p == nil {
		return
	}
	p.id = value
	p.NotifyDirty()
}

func (p *Resource) GetId() uint32 {
	if p == nil {
		return 0
	}
	return p.id
}

func (p *Resource) SetValue(value uint32) {
	if p == nil {
		return
	}
	p.value = value
	p.NotifyDirty()
}

func (p *Resource) GetValue() uint32 {
	if p == nil {
		return 0
	}
	return p.value
}

func (p *Resource) SetSize(value uint32) {
	if p == nil {
		return
	}
	p.size = value
	p.NotifyDirty()
}

func (p *Resource) GetSize() uint32 {
	if p == nil {
		return 0
	}
	return p.size
}

func (p *Resource) fromOrigin(o *dirty_tmpl.Resource) {
	p.id = o.Id
	p.value = o.Value
	p.size = o.Size
}

func (p *Resource) toOrigin() *dirty_tmpl.Resource {
	if p == nil {
		return nil
	}
	o := &dirty_tmpl.Resource{}
	o.Id = p.id
	o.Value = p.value
	o.Size = p.size
	return o
}

func (p *Resource) UnmarshalJSON(data []byte) error {
	origin := &dirty_tmpl.Resource{}
	if err := json.Unmarshal(data, origin); err != nil {
		return err
	}
	p.fromOrigin(origin)
	return nil
}

func (p *Resource) MarshalJSON() ([]byte, error) {
	origin := p.toOrigin()
	return json.Marshal(origin)
}

type Friend struct {
	Base
	uid  uint32
	name string
}

func NewFriend() *Friend {
	p := &Friend{}
	p.self = p
	p.root = p
	return p
}

func (p *Friend) SetUid(value uint32) {
	if p == nil {
		return
	}
	p.uid = value
	p.NotifyDirty()
}

func (p *Friend) GetUid() uint32 {
	if p == nil {
		return 0
	}
	return p.uid
}

func (p *Friend) SetName(value string) {
	if p == nil {
		return
	}
	p.name = value
	p.NotifyDirty()
}

func (p *Friend) GetName() string {
	if p == nil {
		return ""
	}
	return p.name
}

func (p *Friend) fromOrigin(o *dirty_tmpl.Friend) {
	p.uid = o.Uid
	p.name = o.Name
}

func (p *Friend) toOrigin() *dirty_tmpl.Friend {
	if p == nil {
		return nil
	}
	o := &dirty_tmpl.Friend{}
	o.Uid = p.uid
	o.Name = p.name
	return o
}

func (p *Friend) UnmarshalJSON(data []byte) error {
	origin := &dirty_tmpl.Friend{}
	if err := json.Unmarshal(data, origin); err != nil {
		return err
	}
	p.fromOrigin(origin)
	return nil
}

func (p *Friend) MarshalJSON() ([]byte, error) {
	origin := p.toOrigin()
	return json.Marshal(origin)
}

type User struct {
	Base
	name            string
	age             int
	info            *BaseInfo
	_wrap_resources *MapUserResources
	_wrap_friends   *ArrUserFriends
}

type MapUserResources struct {
	Base
	resources map[uint32]*Resource
}

func NewMapUserResources() *MapUserResources {
	p := &MapUserResources{}
	p.resources = make(map[uint32]*Resource)
	p.self = p
	p.root = p
	return p
}

func NewMapUserResourcesFromMap(resources map[uint32]*Resource) *MapUserResources {
	p := &MapUserResources{}
	p.resources = make(map[uint32]*Resource)
	for k, v := range resources {
		p.resources[k] = v
	}
	p.self = p
	p.root = p
	return p
}

func (p *MapUserResources) Get(key uint32) *Resource {
	if p == nil {
		return nil
	}
	return p.resources[key]
}

func (p *MapUserResources) Set(key uint32, value *Resource) {
	if p == nil {
		return
	}
	p.resources[key] = value
	value.root = p.root
	p.NotifyDirty()
}

func (p *MapUserResources) Delete(key uint32) {
	if p == nil {
		return
	}
	delete(p.resources, key)
	p.NotifyDirty()
}

func (p *MapUserResources) Foreach(f func(uint32, *Resource)) {
	if p == nil {
		return
	}
	for k, v := range p.resources {
		f(k, v)
	}
}

func (p *MapUserResources) fromOrigin(o map[uint32]*dirty_tmpl.Resource) {
	for k, v := range o {
		p.resources[k] = NewResource()
		p.resources[k].fromOrigin(v)
	}
}

func (p *MapUserResources) toOrigin() map[uint32]*dirty_tmpl.Resource {
	if p == nil {
		return nil
	}
	o := make(map[uint32]*dirty_tmpl.Resource)
	for k, v := range p.resources {
		o[k] = v.toOrigin()
	}
	return o
}

type ArrUserFriends struct {
	Base
	friends []*Friend
}

func NewArrUserFriends() *ArrUserFriends {
	p := &ArrUserFriends{}
	p.friends = make([]*Friend, 0)
	p.self = p
	p.root = p
	return p
}

func NewArrUserFriendsFromSlice(friends []*Friend) *ArrUserFriends {
	p := &ArrUserFriends{}
	p.friends = make([]*Friend, 0)
	p.friends = append(p.friends, friends...)
	p.self = p
	p.root = p
	return p
}

func (p *ArrUserFriends) Append(value *Friend) {
	if p == nil {
		return
	}
	p.friends = append(p.friends, value)
	value.root = p.root
	p.NotifyDirty()
}

func (p *ArrUserFriends) Index(i int) *Friend {
	if p == nil {
		return nil
	}
	if i < 0 || i >= len(p.friends) {
		return nil
	}
	return p.friends[i]
}

func (p *ArrUserFriends) Foreach(f func(*Friend)) {
	if p == nil {
		return
	}
	for _, v := range p.friends {
		f(v)
	}
}

func (p *ArrUserFriends) fromOrigin(o []*dirty_tmpl.Friend) {
	for _, v := range o {
		val := NewFriend()
		val.fromOrigin(v)
		p.friends = append(p.friends, val)
	}
}

func (p *ArrUserFriends) toOrigin() []*dirty_tmpl.Friend {
	if p == nil {
		return nil
	}
	o := make([]*dirty_tmpl.Friend, 0)
	for _, v := range p.friends {
		o = append(o, v.toOrigin())
	}
	return o
}

func NewUser() *User {
	p := &User{}
	p.self = p
	p.root = p
	return p
}

func (p *User) SetName(value string) {
	if p == nil {
		return
	}
	p.name = value
	p.NotifyDirty()
}

func (p *User) GetName() string {
	if p == nil {
		return ""
	}
	return p.name
}

func (p *User) SetAge(value int) {
	if p == nil {
		return
	}
	p.age = value
	p.NotifyDirty()
}

func (p *User) GetAge() int {
	if p == nil {
		return 0
	}
	return p.age
}

func (p *User) SetInfo(value *BaseInfo) {
	if p == nil {
		return
	}
	p.info = value
	value.root = p.root
	p.NotifyDirty()
}

func (p *User) GetInfo() *BaseInfo {
	if p == nil {
		return nil
	}
	return p.info
}

func (p *User) SetResources(value *MapUserResources) {
	if p == nil {
		return
	}
	p._wrap_resources = value
	value.root = p.root
	for _, v := range value.resources {
		v.root = p.root
	}
	p.NotifyDirty()
}

func (p *User) GetResources() *MapUserResources {
	if p == nil {
		return nil
	}
	return p._wrap_resources
}

func (p *User) SetFriends(value *ArrUserFriends) {
	if p == nil {
		return
	}
	p._wrap_friends = value
	value.root = p.root
	for _, v := range value.friends {
		v.root = p.root
	}
	p.NotifyDirty()
}

func (p *User) GetFriends() *ArrUserFriends {
	if p == nil {
		return nil
	}
	return p._wrap_friends
}

func (p *User) fromOrigin(o *dirty_tmpl.User) {
	p.name = o.Name
	p.age = o.Age
	p.info = NewBaseInfo()
	p.info.fromOrigin(o.Info)
	p._wrap_resources = NewMapUserResources()
	p._wrap_resources.fromOrigin(o.Resources)
	p._wrap_friends = NewArrUserFriends()
	p._wrap_friends.fromOrigin(o.Friends)
}

func (p *User) toOrigin() *dirty_tmpl.User {
	if p == nil {
		return nil
	}
	o := &dirty_tmpl.User{}
	o.Name = p.name
	o.Age = p.age
	o.Info = p.info.toOrigin()
	o.Resources = p._wrap_resources.toOrigin()
	o.Friends = p._wrap_friends.toOrigin()
	return o
}

func (p *User) UnmarshalJSON(data []byte) error {
	origin := &dirty_tmpl.User{}
	if err := json.Unmarshal(data, origin); err != nil {
		return err
	}
	p.fromOrigin(origin)
	return nil
}

func (p *User) MarshalJSON() ([]byte, error) {
	origin := p.toOrigin()
	return json.Marshal(origin)
}
